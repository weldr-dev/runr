# Journal Data Sources - Ground Truth

**Based on actual run**: 20260102075326

---

## Actual Files in Run Directory

```
.runr/runs/20260102075326/
├── artifacts/
│   ├── context-pack.json
│   ├── task.md                    # Full task file (copied)
│   ├── task.meta.json             # { task_path, owns_raw, owns_normalized }
│   ├── tests_tier0.log            # Verification logs
│   └── tests_tier1.log
├── handoffs/
│   ├── milestone_01_handoff.md    # Per-milestone handoffs
│   ├── milestone_02_handoff.md
│   ├── milestone_03_handoff.md
│   ├── milestone_04_handoff.md
│   ├── stop.json                  # Generated by summarize command
│   └── stop.md
├── config.snapshot.json           # Full config + _worktree metadata
├── env.fingerprint.json
├── plan.md                        # Generated plan
├── seq.txt                        # Sequence counter
├── state.json                     # Current state (LARGE - 59KB)
├── summary.json                   # Generated by summarize command
├── summary.md
└── timeline.jsonl                 # All events (LARGE - 212KB)
```

---

## Data Extraction Map (Field → Source)

### Run Identity

| Field | Source | Extraction |
|-------|--------|------------|
| `run_id` | Argument | Passed in |
| `repo_root` | `config.snapshot.json → _worktree.original_repo_path` | Direct read |
| `base_sha` | `config.snapshot.json → _worktree.base_sha` | Direct read |
| `head_sha` | `timeline.jsonl` last checkpoint event OR `git rev-parse HEAD` in worktree | Parse or fallback |
| `task.path` | `artifacts/task.meta.json → task_path` | Direct read |
| `task.sha256` | Compute from `artifacts/task.md` | Hash file |
| `task.title` | Parse `artifacts/task.md` first H1 | Regex: `^# (.+)$` |
| `task.goal` | Parse `artifacts/task.md` "## Goal" section | Extract between `## Goal` and next `##` |

**Fallbacks**:
- If `_worktree` missing → `repo_root` = `process.cwd()`, `base_sha` = null
- If `task.md` missing → `task.title` = null, `task.goal` = null
- If `task.meta.json` missing → `task.path` = null

---

### Status

| Field | Source | Extraction |
|-------|--------|------------|
| `phase` | `state.json → phase` | Direct read |
| `terminal_state` | `summary.json → outcome` | Direct read (or derive from `state.phase`) |
| `stop_reason` | `state.json → stop_reason` OR `summary.json → stop_reason` | Direct read |
| `exit_code` | N/A (not stored) | null for v1 |
| `timestamps.started_at` | `timeline.jsonl` first `run_started` event → timestamp | Parse JSONL |
| `timestamps.ended_at` | `timeline.jsonl` last `stop` event → timestamp | Parse JSONL |

**Fallbacks**:
- If `summary.json` exists (generated by summarize), use it as primary source
- Else compute from `state.json` + `timeline.jsonl`

---

### Checkpoints

**Problem**: Checkpoints aren't explicitly stored in metadata. We need to infer from:
1. Milestone handoff files (`handoffs/milestone_*.md`)
2. Git log on checkpoint branch
3. Timeline events (if they contain checkpoint info)

**Safer v1 approach**: Use git log on the run's branch, filter by commit message pattern.

| Field | Source | Extraction |
|-------|--------|------------|
| `checkpoints[]` | `git log --format='%H|%at|%s' <base_sha>..<run_branch>` | Parse commits with pattern `chore\(agent\): checkpoint milestone (\d+)` |
| `milestone_index` | Regex from commit message | Extract number |
| `title` | Infer from milestone handoff filename OR plan.md | Read `handoffs/milestone_0N_handoff.md`, extract from plan |
| `sha` | Git log output | Direct |
| `created_at` | Git log timestamp | Convert from unix timestamp |
| `last_checkpoint_sha` | Last checkpoint in array | Take last |

**Alternative (more reliable)**: Check if `summary.json` or `state.json` has checkpoint metadata.

**Actual check needed**:
```bash
cat .runr/runs/20260102075326/state.json | jq '.checkpoints // empty'
cat .runr/runs/20260102075326/state.json | jq '.milestones // empty'
```

---

### Verification

**Source**: `timeline.jsonl` events of type `verification`

**Event structure** (from earlier):
```json
{
  "type": "verification",
  "source": "verifier",
  "payload": {
    "tier": "tier1",
    "ok": false,
    "commands": ["npm test"],
    "command_results": [{
      "command": "npm test",
      "exit_code": 1,
      "output": "..."
    }],
    "duration_ms": 11164
  },
  "seq": 62,
  "timestamp": "2026-01-02T08:09:24.734Z"
}
```

| Field | Source | Extraction |
|-------|--------|------------|
| `summary.attempts_total` | Count all `verification` events | Count events |
| `summary.attempts_passed` | Count `verification` events where `payload.ok === true` | Filter + count |
| `summary.attempts_failed` | Count `verification` events where `payload.ok === false` | Filter + count |
| `summary.total_duration_seconds` | Sum `payload.duration_ms` from all verification events | Sum + convert to seconds |
| `last_failure.command` | Last verification event with `ok: false` → `payload.commands[0]` | Last failed event |
| `last_failure.exit_code` | Last verification event → `payload.command_results[0].exit_code` | Last failed event |
| `last_failure.error_excerpt` | Last verification event → `payload.command_results[0].output` | Last 60 lines, redacted |
| `last_failure.log_path` | `artifacts/tests_<tier>.log` based on tier | Construct path from tier |

**Better field names** (user's suggestion):
```json
"verification": {
  "summary": {
    "attempts_total": 13,
    "attempts_passed": 0,
    "attempts_failed": 13,
    "total_duration_seconds": 54
  },
  "last_failure": { ... }
}
```

---

### Changes

**Source**: Git commands using stored SHAs

| Field | Source | Extraction |
|-------|--------|------------|
| `base_sha` | `config.snapshot.json → _worktree.base_sha` | Direct read (redundant but explicit) |
| `head_sha` | Last checkpoint sha OR `git rev-parse <run_branch>` | Git command |
| `files_changed` | `git diff --numstat <base_sha>..<head_sha>` | Count lines |
| `insertions` | `git diff --numstat <base_sha>..<head_sha>` | Sum column 1 |
| `deletions` | `git diff --numstat <base_sha>..<head_sha>` | Sum column 2 |
| `top_files[]` | `git diff --numstat <base_sha>..<head_sha>` | Sort by total changes, take top 10 |
| `diff_stat` | `git diff --stat <base_sha>..<head_sha>` | Direct output |

**Critical**: Always use `<base_sha>..<head_sha>` from snapshot, NEVER current HEAD.

**Fallback**: If git commands fail, set all to null + add warning.

---

### Next Action

**Source**: `handoffs/stop.json` (if exists)

| Field | Source | Extraction |
|-------|--------|------------|
| `next_action.title` | `stop.json → next_actions[0].title` | Direct read |
| `next_action.command` | `stop.json → next_actions[0].command` | Direct read |
| `next_action.why` | `stop.json → next_actions[0].why` | Direct read |

**Fallback**: If `stop.json` doesn't exist:
- If `stop_reason === "verification_failed_max_retries"` → default to "View verification logs"
- Else → null

**Note**: `stop.json` is generated by `runr summarize` command, so it may not exist for old runs.

---

### Notes

**Source**: `notes.jsonl` (may not exist for v1, we're creating it)

| Field | Source | Extraction |
|-------|--------|------------|
| `notes.count` | Count lines in `notes.jsonl` | Line count |
| `notes.path` | Hardcoded relative path | `"notes.jsonl"` |

**Fallback**: If file doesn't exist → `count: 0`, `path: "notes.jsonl"`

---

### Resume Context

**Source**: `timeline.jsonl` events (if exists)

**Check for event type**: `resumed_from` or similar

**Actual check needed**:
```bash
grep -i "resume" .runr/runs/20260102075326/timeline.jsonl | head -1
```

**For v1**: Set to null unless we find evidence of resume events in timeline.

---

## State.json Deep Dive

**Actual structure** (need to read to confirm):
```bash
cat .runr/runs/20260102075326/state.json | jq 'keys'
```

**Expected fields** (based on RunState type):
- `phase`: Current phase
- `stop_reason`: Why stopped
- `milestone_index`: Current milestone
- `milestones[]`: Array of milestone objects (contains plan)
- `checkpoints[]`: ?? (need to check if this exists)
- `last_error`: Last error message

**Critical question**: Does `state.json` have checkpoint metadata or not?

---

## Summary.json Deep Dive

**Actual structure** (already read earlier):
```json
{
  "run_id": "20260102075326",
  "outcome": "stopped",
  "stop_reason": "verification_failed_max_retries",
  "duration_seconds": 950,
  "milestones": {
    "completed": 0,      // ← THIS IS THE INCONSISTENCY
    "total": 4
  },
  "verification": {
    "attempts": 13,
    "retries": 0,
    "duration_seconds": 54
  },
  ...
}
```

**Problem**: `milestones.completed: 0` but we have 3 checkpoints.

**Root cause**: "completed" likely means "passed final verification" not "checkpoint created".

**Fix for Journal**:
- Rename to `milestones_verified: 0` (clearer)
- Add `checkpoints_created: 3` (separate field)

---

## Milestone Completion Semantics (MUST DEFINE)

**Options**:

1. **Milestone completed = checkpoint created**
   - Then: `completed: 3 / 4`
   - Checkpoints table shows the 3 completed

2. **Milestone completed = passed final verification**
   - Then: `completed: 0 / 4` (run stopped before any milestone verified)
   - Checkpoints table shows "attempted but not verified"

3. **Separate concepts**:
   - `milestones_attempted: 4`
   - `milestones_verified: 0`
   - `checkpoints_created: 3`

**User is right**: The example contradicts itself. Need to pick one definition and be consistent.

**Best for v1**: Use option 3 (most explicit).

---

## Git Log for Checkpoints (Verification)

**Test**:
```bash
cd /Users/vonwao/dev/agent-framework
git log --oneline agent/20260102075326/dogfood-01-polish-init | head -5
```

**Actual output** (from earlier):
```
5c98ffa chore(agent): checkpoint milestone 3
7e5b62c chore(agent): checkpoint milestone 2
82eb3c2 chore(agent): checkpoint milestone 1
61f830b feat: add 3 dogfood task files for Day 3-4
4c7ae7a Day 2: COMPLETE ✅
```

**Parsing**:
- Regex: `^([a-f0-9]+) chore\(agent\): checkpoint milestone (\d+)$`
- Extract: SHA, milestone index
- Map to milestone title from `state.json → milestones[index]` OR `plan.md`

**Fallback**: If commit message pattern doesn't match, use SHA only, title = "Milestone N"

---

## Warnings Array (MUST ADD)

**Add to schema**:
```json
{
  "warnings": [
    "Git command failed: git diff --stat <base>..<head>. Change summary unavailable.",
    "task.md not found. Task title/goal unavailable.",
    "stop.json not found. Next action derived from stop_reason."
  ]
}
```

**Use case**: Every try-catch should append to warnings array.

---

## Auto-Write Hook (FIX CONDITION)

**Current plan says**:
```typescript
if (state.phase === 'STOPPED' || state.phase === 'COMPLETE') {
```

**Problem**: Phases might not be named exactly this.

**Fix**: Check actual state machine. Likely:
```typescript
// Check terminal state, not phase name
if (isTerminalState(state)) {
  // Auto-write journal
}

function isTerminalState(state: RunState): boolean {
  return state.phase === 'STOPPED' || state.phase === 'COMPLETE';
  // OR check state.terminal_state if that field exists
}
```

**Need to verify**: What are the actual terminal phase names in the state machine?

---

## Notes Invalidation (IMPROVE)

**Current plan**: Delete `journal.md` after adding note.

**Better**:
```typescript
function shouldRegenerate(journalMdPath: string, stateJsonPath: string, notesPath: string): boolean {
  if (!fs.existsSync(journalMdPath)) return true;

  const journalMtime = fs.statSync(journalMdPath).mtimeMs;

  // Regen if state.json is newer
  if (fs.existsSync(stateJsonPath)) {
    const stateMtime = fs.statSync(stateJsonPath).mtimeMs;
    if (stateMtime > journalMtime) return true;
  }

  // Regen if notes.jsonl is newer
  if (fs.existsSync(notesPath)) {
    const notesMtime = fs.statSync(notesPath).mtimeMs;
    if (notesMtime > journalMtime) return true;
  }

  return false;
}
```

---

## Redaction (REALISTIC V1)

**Don't over-promise**. Say:
- "Basic redaction applied to error excerpts"
- Show `[REDACTED]` markers where redaction occurred
- Don't claim perfect DLP

**Patterns to redact**:
```typescript
function redactSecrets(text: string): string {
  let redacted = text;

  // AWS keys
  redacted = redacted.replace(/AKIA[0-9A-Z]{16}/g, '[REDACTED_AWS_KEY]');

  // Generic API keys in env var format
  redacted = redacted.replace(/\b(API_KEY|SECRET_KEY|ACCESS_TOKEN|PRIVATE_KEY|PASSWORD)=["']?[^\s"']+/gi, '$1=[REDACTED]');

  // Bearer tokens
  redacted = redacted.replace(/Bearer\s+[A-Za-z0-9\-._~+/]+=*/g, 'Bearer [REDACTED]');

  // PEM blocks
  redacted = redacted.replace(/-----BEGIN [A-Z ]+-----[\s\S]+?-----END [A-Z ]+-----/g, '[REDACTED_PEM_BLOCK]');

  return redacted;
}
```

---

## Revised Example (CONSISTENT)

```markdown
## Status

- **Phase**: VERIFY
- **Outcome**: stopped
- **Stop Reason**: verification_failed_max_retries
- **Milestones Attempted**: 4
- **Milestones Verified**: 0
- **Checkpoints Created**: 3
```

This is consistent with the checkpoints table showing 3 entries.

---

## Summary of Changes Needed

### Must-Fix (Blocking)

1. ✅ **Audit actual file structure** - done above
2. ✅ **Fix milestone completion semantics** - use separate fields
3. ✅ **Fix verification summary fields** - rename to attempts_total/passed/failed
4. ✅ **Add warnings array to schema**
5. ✅ **Fix checkpoint extraction** - use git log with fallback
6. ✅ **Fix auto-write hook condition** - check actual terminal phase names
7. ✅ **Improve notes invalidation** - use mtime comparison
8. ✅ **Fix example to be consistent**

### Should-Fix (High ROI)

9. ✅ **Make redaction realistic** - don't over-promise
10. ✅ **Store repo_root + relative paths** - for portability
11. ✅ **Derive next_action with fallback** - don't require stop.json

---

**Next**: I'll revise the plan with these fixes and create a final "APPROVED" version grounded in reality.
